/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, Input } from '@angular/core';
import { NgxHotkeysService } from '../ngx-hotkeys.service';
export class NgxCheatsheetComponent {
    /**
     * @param {?} hotkeysService
     */
    constructor(hotkeysService) {
        this.hotkeysService = hotkeysService;
        this.helpVisible = false;
        this._map = {
            command: '\u2318',
            // ⌘
            shift: '\u21E7',
            // ⇧
            left: '\u2190',
            // ←
            right: '\u2192',
            // →
            up: '\u2191',
            // ↑
            down: '\u2193',
            // ↓
            'return': '\u23CE',
            // ⏎
            backspace: '\u232B' // ⌫
        };
        this.title = this.hotkeysService.options.cheatSheetTitle;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._subscription = this.hotkeysService.cheatSheetToggled
            .subscribe((isOpen) => {
            if (isOpen !== false) {
                this.hotkeys = this.hotkeysService.hotkeys
                    .filter(hotkey => hotkey.description);
            }
            if (isOpen === false) {
                this.helpVisible = false;
            }
            else {
                this.toggleCheatSheet();
            }
        });
    }
    /**
     * @param {?} hotkey
     * @return {?}
     */
    formatHotkey(hotkey) {
        if (!hotkey.format) {
            const /** @type {?} */ combo = Array.isArray(hotkey.combo) ? hotkey.combo[0] : hotkey.combo;
            const /** @type {?} */ sequence = combo.split(/[\s]/);
            for (let /** @type {?} */ i = 0; i < sequence.length; i++) {
                sequence[i] = this.symbolize(sequence[i]);
            }
            hotkey.format = sequence;
        }
        return hotkey.format;
    }
    /**
     * @param {?} combo
     * @return {?}
     */
    symbolize(combo) {
        const /** @type {?} */ comboSplit = combo.split('+');
        for (let /** @type {?} */ i = 0; i < comboSplit.length; i++) {
            // try to resolve command / ctrl based on OS:
            if (comboSplit[i] === 'mod') {
                if (window.navigator && window.navigator.platform.indexOf('Mac') >= 0) {
                    comboSplit[i] = 'command';
                }
                else {
                    comboSplit[i] = 'ctrl';
                }
            }
            comboSplit[i] = this._map[comboSplit[i]] || comboSplit[i];
        }
        return comboSplit.join(' + ');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    toggleCheatSheet() {
        this.helpVisible = !this.helpVisible;
    }
}
NgxCheatsheetComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-cheatsheet',
                template: `<div class="ngx-cheatsheet fade" [ngClass]="{'in': helpVisible}" style="display:none">
  <div class="ngx-cheatsheet__hotkeys">
    <h4 class="ngx-cheatsheet__hotkeys__title">{{ title }}</h4>
    <table>
      <tbody>
      <tr *ngFor="let hotkey of hotkeys">
        <td class="ngx-cheatsheet__hotkeys__keys">
          <span class="ngx-cheatsheet__hotkeys__keys__key">{{ formatHotkey(hotkey) }}</span>
        </td>
        <td class="ngx-cheatsheet__hotkeys__keys__text">{{ hotkey.description }}</td>
      </tr>
      </tbody>
    </table>
    <div class="ngx-cheatsheet__hotkeys__close" (click)="toggleCheatSheet()">&#215;</div>
  </div>
</div>
`,
                styles: [`.ngx-cheatsheet{display:table!important;position:fixed;width:100%;height:100%;top:0;left:0;color:#333;font-size:1em;background-color:rgba(255,255,255,.9)}.ngx-cheatsheet.fade{z-index:-1024;visibility:hidden;opacity:0;transition:opacity .15s linear}.ngx-cheatsheet.fade.in{z-index:10002;visibility:visible;opacity:1}.ngx-cheatsheet__hotkeys{width:100%;height:100%;display:table-cell;vertical-align:middle}.ngx-cheatsheet__hotkeys__title{font-weight:700;text-align:center;font-size:1.2em}.ngx-cheatsheet__hotkeys table{margin:auto;color:#333}.ngx-cheatsheet__hotkeys__keys{padding:5px;text-align:right}.ngx-cheatsheet__hotkeys__keys__key{display:inline-block;color:#fff;background-color:#333;border:1px solid #333;border-radius:5px;text-align:center;margin-right:5px;box-shadow:inset 0 1px 0 #666,0 1px 0 #bbb;padding:5px 9px;font-size:1em}.ngx-cheatsheet__hotkeys__keys__text{padding-left:10px;font-size:1em}.ngx-cheatsheet__hotkeys__close{position:fixed;top:20px;right:20px;font-size:2em;font-weight:700;padding:5px 10px;border:1px solid #ddd;border-radius:5px;min-height:45px;min-width:45px;text-align:center}@media all and (max-width:500px){.ngx-cheatsheet__hotkeys{font-size:.8em}}@media all and (min-width:750px){.ngx-cheatsheet__hotkeys{font-size:1.2em}}`]
            },] },
];
/** @nocollapse */
NgxCheatsheetComponent.ctorParameters = () => [
    { type: NgxHotkeysService, },
];
NgxCheatsheetComponent.propDecorators = {
    "title": [{ type: Input },],
};
function NgxCheatsheetComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    NgxCheatsheetComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    NgxCheatsheetComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    NgxCheatsheetComponent.propDecorators;
    /** @type {?} */
    NgxCheatsheetComponent.prototype.title;
    /** @type {?} */
    NgxCheatsheetComponent.prototype.helpVisible;
    /** @type {?} */
    NgxCheatsheetComponent.prototype.hotkeys;
    /** @type {?} */
    NgxCheatsheetComponent.prototype._subscription;
    /** @type {?} */
    NgxCheatsheetComponent.prototype._map;
    /** @type {?} */
    NgxCheatsheetComponent.prototype.hotkeysService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNoZWF0c2hlZXQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvIiwic291cmNlcyI6WyJsaWIvbmd4LWNoZWF0c2hlZXQvbmd4LWNoZWF0c2hlZXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLEtBQUssRUFBb0IsTUFBTSxlQUFlLENBQUM7QUFHbEUsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUF3QnpELE1BQU07Ozs7SUFxQkosWUFBb0IsY0FBaUM7UUFBakMsbUJBQWMsR0FBZCxjQUFjLENBQW1COzJCQWhCdkMsS0FBSztvQkFLQztZQUNsQixPQUFPLEVBQUUsUUFBUTs7WUFDakIsS0FBSyxFQUFFLFFBQVE7O1lBQ2YsSUFBSSxFQUFFLFFBQVE7O1lBQ2QsS0FBSyxFQUFFLFFBQVE7O1lBQ2YsRUFBRSxFQUFFLFFBQVE7O1lBQ1osSUFBSSxFQUFFLFFBQVE7O1lBQ2QsUUFBUSxFQUFFLFFBQVE7O1lBQ2xCLFNBQVMsRUFBRSxRQUFRO1NBQ3BCO1FBR0MsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUM7S0FDMUQ7Ozs7SUFFRCxRQUFRO1FBQ04sSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGlCQUFpQjthQUN2RCxTQUFTLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNwQixFQUFFLENBQUMsQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU87cUJBQ3ZDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUN6QztZQUVELEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNyQixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQzthQUMxQjtZQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNOLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO2FBQ3pCO1NBQ0YsQ0FBQyxDQUFDO0tBQ047Ozs7O0lBRUQsWUFBWSxDQUFDLE1BQWU7UUFDMUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNuQix1QkFBTSxLQUFLLEdBQVcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7WUFDbkYsdUJBQU0sUUFBUSxHQUFhLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDL0MsR0FBRyxDQUFDLENBQUMscUJBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUN6QyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMzQztZQUNELE1BQU0sQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDO1NBQzFCO1FBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7S0FDdEI7Ozs7O0lBRU8sU0FBUyxDQUFDLEtBQWE7UUFDN0IsdUJBQU0sVUFBVSxHQUFhLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUMsR0FBRyxDQUFDLENBQUMscUJBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDOztZQUUzQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDNUIsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDdEUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQztpQkFDM0I7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztpQkFDeEI7YUFDRjtZQUNELFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzRDtRQUNELE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7OztJQUdoQyxXQUFXO1FBQ1QsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNsQztLQUNGOzs7O0lBRU0sZ0JBQWdCO1FBQ3JCLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7O1lBakd4QyxTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JYO2dCQUNDLE1BQU0sRUFBRSxDQUFDLDZ1Q0FBNnVDLENBQUM7YUFDeHZDOzs7O1lBdkJPLGlCQUFpQjs7O3NCQTBCdEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQge05neEhvdGtleXNTZXJ2aWNlfSBmcm9tICcuLi9uZ3gtaG90a2V5cy5zZXJ2aWNlJztcbmltcG9ydCB7SUhvdGtleX0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC1jaGVhdHNoZWV0JyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwibmd4LWNoZWF0c2hlZXQgZmFkZVwiIFtuZ0NsYXNzXT1cInsnaW4nOiBoZWxwVmlzaWJsZX1cIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPlxuICA8ZGl2IGNsYXNzPVwibmd4LWNoZWF0c2hlZXRfX2hvdGtleXNcIj5cbiAgICA8aDQgY2xhc3M9XCJuZ3gtY2hlYXRzaGVldF9faG90a2V5c19fdGl0bGVcIj57eyB0aXRsZSB9fTwvaDQ+XG4gICAgPHRhYmxlPlxuICAgICAgPHRib2R5PlxuICAgICAgPHRyICpuZ0Zvcj1cImxldCBob3RrZXkgb2YgaG90a2V5c1wiPlxuICAgICAgICA8dGQgY2xhc3M9XCJuZ3gtY2hlYXRzaGVldF9faG90a2V5c19fa2V5c1wiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwibmd4LWNoZWF0c2hlZXRfX2hvdGtleXNfX2tleXNfX2tleVwiPnt7IGZvcm1hdEhvdGtleShob3RrZXkpIH19PC9zcGFuPlxuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgY2xhc3M9XCJuZ3gtY2hlYXRzaGVldF9faG90a2V5c19fa2V5c19fdGV4dFwiPnt7IGhvdGtleS5kZXNjcmlwdGlvbiB9fTwvdGQ+XG4gICAgICA8L3RyPlxuICAgICAgPC90Ym9keT5cbiAgICA8L3RhYmxlPlxuICAgIDxkaXYgY2xhc3M9XCJuZ3gtY2hlYXRzaGVldF9faG90a2V5c19fY2xvc2VcIiAoY2xpY2spPVwidG9nZ2xlQ2hlYXRTaGVldCgpXCI+JiMyMTU7PC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5gLFxuICBzdHlsZXM6IFtgLm5neC1jaGVhdHNoZWV0e2Rpc3BsYXk6dGFibGUhaW1wb3J0YW50O3Bvc2l0aW9uOmZpeGVkO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7dG9wOjA7bGVmdDowO2NvbG9yOiMzMzM7Zm9udC1zaXplOjFlbTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjU1LDI1NSwyNTUsLjkpfS5uZ3gtY2hlYXRzaGVldC5mYWRle3otaW5kZXg6LTEwMjQ7dmlzaWJpbGl0eTpoaWRkZW47b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuMTVzIGxpbmVhcn0ubmd4LWNoZWF0c2hlZXQuZmFkZS5pbnt6LWluZGV4OjEwMDAyO3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjF9Lm5neC1jaGVhdHNoZWV0X19ob3RrZXlze3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubmd4LWNoZWF0c2hlZXRfX2hvdGtleXNfX3RpdGxle2ZvbnQtd2VpZ2h0OjcwMDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXNpemU6MS4yZW19Lm5neC1jaGVhdHNoZWV0X19ob3RrZXlzIHRhYmxle21hcmdpbjphdXRvO2NvbG9yOiMzMzN9Lm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX19rZXlze3BhZGRpbmc6NXB4O3RleHQtYWxpZ246cmlnaHR9Lm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX19rZXlzX19rZXl7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7Ym9yZGVyOjFweCBzb2xpZCAjMzMzO2JvcmRlci1yYWRpdXM6NXB4O3RleHQtYWxpZ246Y2VudGVyO21hcmdpbi1yaWdodDo1cHg7Ym94LXNoYWRvdzppbnNldCAwIDFweCAwICM2NjYsMCAxcHggMCAjYmJiO3BhZGRpbmc6NXB4IDlweDtmb250LXNpemU6MWVtfS5uZ3gtY2hlYXRzaGVldF9faG90a2V5c19fa2V5c19fdGV4dHtwYWRkaW5nLWxlZnQ6MTBweDtmb250LXNpemU6MWVtfS5uZ3gtY2hlYXRzaGVldF9faG90a2V5c19fY2xvc2V7cG9zaXRpb246Zml4ZWQ7dG9wOjIwcHg7cmlnaHQ6MjBweDtmb250LXNpemU6MmVtO2ZvbnQtd2VpZ2h0OjcwMDtwYWRkaW5nOjVweCAxMHB4O2JvcmRlcjoxcHggc29saWQgI2RkZDtib3JkZXItcmFkaXVzOjVweDttaW4taGVpZ2h0OjQ1cHg7bWluLXdpZHRoOjQ1cHg7dGV4dC1hbGlnbjpjZW50ZXJ9QG1lZGlhIGFsbCBhbmQgKG1heC13aWR0aDo1MDBweCl7Lm5neC1jaGVhdHNoZWV0X19ob3RrZXlze2ZvbnQtc2l6ZTouOGVtfX1AbWVkaWEgYWxsIGFuZCAobWluLXdpZHRoOjc1MHB4KXsubmd4LWNoZWF0c2hlZXRfX2hvdGtleXN7Zm9udC1zaXplOjEuMmVtfX1gXVxufSlcbmV4cG9ydCBjbGFzcyBOZ3hDaGVhdHNoZWV0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gIEBJbnB1dCgpXG4gIHRpdGxlOiBzdHJpbmc7XG5cbiAgaGVscFZpc2libGUgPSBmYWxzZTtcbiAgaG90a2V5czogSUhvdGtleVtdO1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIHByaXZhdGUgX21hcDogYW55ID0ge1xuICAgIGNvbW1hbmQ6ICdcXHUyMzE4JywgICAgICAgLy8g4oyYXG4gICAgc2hpZnQ6ICdcXHUyMUU3JywgICAgICAgICAvLyDih6dcbiAgICBsZWZ0OiAnXFx1MjE5MCcsICAgICAgICAgIC8vIOKGkFxuICAgIHJpZ2h0OiAnXFx1MjE5MicsICAgICAgICAgLy8g4oaSXG4gICAgdXA6ICdcXHUyMTkxJywgICAgICAgICAgICAvLyDihpFcbiAgICBkb3duOiAnXFx1MjE5MycsICAgICAgICAgIC8vIOKGk1xuICAgICdyZXR1cm4nOiAnXFx1MjNDRScsICAgICAgLy8g4o+OXG4gICAgYmFja3NwYWNlOiAnXFx1MjMyQicgICAgICAvLyDijKtcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGhvdGtleXNTZXJ2aWNlOiBOZ3hIb3RrZXlzU2VydmljZSkge1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLmhvdGtleXNTZXJ2aWNlLm9wdGlvbnMuY2hlYXRTaGVldFRpdGxlO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5ob3RrZXlzU2VydmljZS5jaGVhdFNoZWV0VG9nZ2xlZFxuICAgICAgLnN1YnNjcmliZSgoaXNPcGVuKSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5ob3RrZXlzID0gdGhpcy5ob3RrZXlzU2VydmljZS5ob3RrZXlzXG4gICAgICAgICAgICAuZmlsdGVyKGhvdGtleSA9PiBob3RrZXkuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmhlbHBWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50b2dnbGVDaGVhdFNoZWV0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgZm9ybWF0SG90a2V5KGhvdGtleTogSUhvdGtleSk6IHN0cmluZ1tdIHtcbiAgICBpZiAoIWhvdGtleS5mb3JtYXQpIHtcbiAgICAgIGNvbnN0IGNvbWJvOiBzdHJpbmcgPSBBcnJheS5pc0FycmF5KGhvdGtleS5jb21ibykgPyBob3RrZXkuY29tYm9bMF0gOiBob3RrZXkuY29tYm87XG4gICAgICBjb25zdCBzZXF1ZW5jZTogc3RyaW5nW10gPSBjb21iby5zcGxpdCgvW1xcc10vKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VxdWVuY2VbaV0gPSB0aGlzLnN5bWJvbGl6ZShzZXF1ZW5jZVtpXSk7XG4gICAgICB9XG4gICAgICBob3RrZXkuZm9ybWF0ID0gc2VxdWVuY2U7XG4gICAgfVxuICAgIHJldHVybiBob3RrZXkuZm9ybWF0O1xuICB9XG5cbiAgcHJpdmF0ZSBzeW1ib2xpemUoY29tYm86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgY29tYm9TcGxpdDogc3RyaW5nW10gPSBjb21iby5zcGxpdCgnKycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tYm9TcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gdHJ5IHRvIHJlc29sdmUgY29tbWFuZCAvIGN0cmwgYmFzZWQgb24gT1M6XG4gICAgICBpZiAoY29tYm9TcGxpdFtpXSA9PT0gJ21vZCcpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSA+PSAwKSB7XG4gICAgICAgICAgY29tYm9TcGxpdFtpXSA9ICdjb21tYW5kJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21ib1NwbGl0W2ldID0gJ2N0cmwnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb21ib1NwbGl0W2ldID0gdGhpcy5fbWFwW2NvbWJvU3BsaXRbaV1dIHx8IGNvbWJvU3BsaXRbaV07XG4gICAgfVxuICAgIHJldHVybiBjb21ib1NwbGl0LmpvaW4oJyArICcpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRvZ2dsZUNoZWF0U2hlZXQoKTogdm9pZCB7XG4gICAgdGhpcy5oZWxwVmlzaWJsZSA9ICF0aGlzLmhlbHBWaXNpYmxlO1xuICB9XG59XG4iXX0=