import { InjectionToken, Inject, Injectable, Directive, ElementRef, Input, Component, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import 'mousetrap';
import { share } from 'rxjs/internal/operators';
import { __values } from 'tslib';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ HotkeyOptions = new InjectionToken('HotkeyOptions');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ _defaultOptions = {
    disableCheatSheet: false,
    cheatSheetTitle: 'Keyboard Shortcuts:',
    cheatSheetHotkey: '?',
    cheatSheetHotkeyDescription: 'Show / hide this help menu',
    cheatSheetCloseEsc: false,
    cheatSheetCloseEscDescription: 'Hide this help menu'
};
var NgxHotkeysService = /** @class */ (function () {
    function NgxHotkeysService(_options) {
        this._options = _options;
        this._registeredHotkeys = new Set();
        this._pausedHotkeys = new Set();
        this._cheatSheetToggled = new Subject();
        this._preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];
        this._serviceOptions = Object.assign(_defaultOptions, this._options);
        Mousetrap.prototype.stopCallback = function (event, element, combo, callback) {
            // if the element has the class "mousetrap" then no need to stop
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }
            return (element.contentEditable && element.contentEditable === 'true');
        };
        this._mousetrapInstance = new (/** @type {?} */ (Mousetrap))();
        if (!this._serviceOptions.disableCheatSheet) {
            this.register({
                combo: this._serviceOptions.cheatSheetHotkey,
                handler: function (event) {
                    this._cheatSheetToggled.next();
                }.bind(this),
                description: this._serviceOptions.cheatSheetHotkeyDescription
            });
        }
        if (this._serviceOptions.cheatSheetCloseEsc) {
            this.register({
                combo: 'esc',
                handler: function (event) {
                    this._cheatSheetToggled.next(false);
                }.bind(this),
                allowIn: ['HOTKEYS-CHEATSHEET'],
                description: this._serviceOptions.cheatSheetCloseEscDescription
            });
        }
    }
    Object.defineProperty(NgxHotkeysService.prototype, "hotkeys", {
        get: /**
         * Returns the registered hotkeys as array.
         * @return {?} all registered hotkeys
         */
        function () {
            return Array.from(this._registeredHotkeys);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxHotkeysService.prototype, "cheatSheetToggled", {
        get: /**
         * Returns an Observable stream indicating the cheatsheets visibility was toggled.
         * @return {?} stream indicating the cheatsheets visibility was toggled
         */
        function () {
            return this._cheatSheetToggled.asObservable().pipe(share());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxHotkeysService.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            return this._serviceOptions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    NgxHotkeysService.prototype.register = /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    function (hotkey, unpausing) {
        var _this = this;
        if (unpausing === void 0) { unpausing = false; }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        if (unpausing) {
            hotkeys = Array.from(this._pausedHotkeys);
        }
        hotkeys.forEach(function (h) {
            if (unpausing) {
                _this._pausedHotkeys.delete(h);
            }
            _this._registeredHotkeys.add(h);
            _this.bindToMoustrap(h);
        });
    };
    /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    NgxHotkeysService.prototype.unregister = /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    function (hotkey, pausing) {
        var _this = this;
        if (pausing === void 0) { pausing = false; }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        hotkeys.forEach(function (h) {
            _this._registeredHotkeys.delete(h);
            if (pausing) {
                _this._pausedHotkeys.add(h);
            }
            _this._mousetrapInstance.unbind(h.combo, h.specificEvent);
        });
    };
    /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    NgxHotkeysService.prototype.get = /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    function (combo) {
        return this.hotkeys.filter(function (h) { return h.combo === combo; });
    };
    /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    NgxHotkeysService.prototype.pause = /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    function (hotkey) {
        if (!hotkey) {
            return this.pause(this.hotkeys);
        }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        this.unregister(hotkeys, true);
    };
    /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    NgxHotkeysService.prototype.unpause = /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    function (hotkey) {
        if (!hotkey) {
            return this.unpause(this.hotkeys);
        }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        this.register(hotkeys, true);
    };
    /**
     * Resets all hotkeys.
     * @return {?}
     */
    NgxHotkeysService.prototype.reset = /**
     * Resets all hotkeys.
     * @return {?}
     */
    function () {
        this._mousetrapInstance.reset();
        this._registeredHotkeys.clear();
        this._pausedHotkeys.clear();
    };
    /**
     * @return {?}
     */
    NgxHotkeysService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.reset();
    };
    /**
     * @param {?} hotkey
     * @return {?}
     */
    NgxHotkeysService.prototype.bindToMoustrap = /**
     * @param {?} hotkey
     * @return {?}
     */
    function (hotkey) {
        var _this = this;
        this._mousetrapInstance.bind(hotkey.combo, function (event, combo) {
            var /** @type {?} */ shouldExecute = true;
            // if the callback is executed directly `hotkey.get('w').callback()`
            // there will be no event, so just execute the callback.
            if (event) {
                var /** @type {?} */ target = /** @type {?} */ ((event.target || event.srcElement)); // srcElement is IE only
                var /** @type {?} */ nodeName = target.nodeName.toUpperCase();
                // check if the input has a mousetrap class, and skip checking preventIn if so
                if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {
                    shouldExecute = true;
                }
                else if (_this._preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(function (allow) { return allow.toUpperCase(); }).indexOf(nodeName) === -1) {
                    // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn
                    shouldExecute = false;
                }
            }
            if (shouldExecute) {
                return hotkey.handler.apply(_this, [event, combo]);
            }
        }, hotkey.specificEvent);
    };
    NgxHotkeysService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NgxHotkeysService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [HotkeyOptions,] },] },
    ]; };
    return NgxHotkeysService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgxHotkeysDirective = /** @class */ (function () {
    function NgxHotkeysDirective(_hotkeysService, _elementRef) {
        this._hotkeysService = _hotkeysService;
        this._elementRef = _elementRef;
        this._hotkeysList = [];
        this._oldHotkeys = [];
        this._mousetrapInstance = new Mousetrap(this._elementRef.nativeElement); // Bind hotkeys to the current element (and any children)
    }
    /**
     * @return {?}
     */
    NgxHotkeysDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        try {
            for (var _a = __values(this.hotkeys), _b = _a.next(); !_b.done; _b = _a.next()) {
                var hotkey = _b.value;
                var /** @type {?} */ combo = Object.keys(hotkey)[0];
                var /** @type {?} */ hotkeyObj = {
                    combo: combo,
                    handler: hotkey[combo]
                };
                var /** @type {?} */ filtered = this._hotkeysService.get(combo);
                var /** @type {?} */ oldHotkey = !!filtered && !!filtered.length ? filtered[0] : null;
                if (oldHotkey !== null) {
                    // We let the user overwrite callbacks temporarily if you specify it in HTML
                    this._oldHotkeys.push(oldHotkey);
                    this._hotkeysService.unregister(oldHotkey);
                }
                this._hotkeysList.push(hotkeyObj);
                this._mousetrapInstance.bind(hotkeyObj.combo, hotkeyObj.handler);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var e_1, _c;
    };
    /**
     * @return {?}
     */
    NgxHotkeysDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        try {
            for (var _a = __values(this._hotkeysList), _b = _a.next(); !_b.done; _b = _a.next()) {
                var hotkey = _b.value;
                this._mousetrapInstance.unbind(hotkey.combo);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this._hotkeysService.register(this._oldHotkeys);
        var e_2, _c;
    };
    NgxHotkeysDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngxHotkeys]',
                    providers: [NgxHotkeysService]
                },] },
    ];
    /** @nocollapse */
    NgxHotkeysDirective.ctorParameters = function () { return [
        { type: NgxHotkeysService, },
        { type: ElementRef, },
    ]; };
    NgxHotkeysDirective.propDecorators = {
        "hotkeys": [{ type: Input },],
    };
    return NgxHotkeysDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgxCheatsheetComponent = /** @class */ (function () {
    function NgxCheatsheetComponent(hotkeysService) {
        this.hotkeysService = hotkeysService;
        this.helpVisible = false;
        this._map = {
            command: '\u2318',
            // ⌘
            shift: '\u21E7',
            // ⇧
            left: '\u2190',
            // ←
            right: '\u2192',
            // →
            up: '\u2191',
            // ↑
            down: '\u2193',
            // ↓
            'return': '\u23CE',
            // ⏎
            backspace: '\u232B' // ⌫
        };
        this.title = this.hotkeysService.options.cheatSheetTitle;
    }
    /**
     * @return {?}
     */
    NgxCheatsheetComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscription = this.hotkeysService.cheatSheetToggled
            .subscribe(function (isOpen) {
            if (isOpen !== false) {
                _this.hotkeys = _this.hotkeysService.hotkeys
                    .filter(function (hotkey) { return hotkey.description; });
            }
            if (isOpen === false) {
                _this.helpVisible = false;
            }
            else {
                _this.toggleCheatSheet();
            }
        });
    };
    /**
     * @param {?} hotkey
     * @return {?}
     */
    NgxCheatsheetComponent.prototype.formatHotkey = /**
     * @param {?} hotkey
     * @return {?}
     */
    function (hotkey) {
        if (!hotkey.format) {
            var /** @type {?} */ combo = Array.isArray(hotkey.combo) ? hotkey.combo[0] : hotkey.combo;
            var /** @type {?} */ sequence = combo.split(/[\s]/);
            for (var /** @type {?} */ i = 0; i < sequence.length; i++) {
                sequence[i] = this.symbolize(sequence[i]);
            }
            hotkey.format = sequence;
        }
        return hotkey.format;
    };
    /**
     * @param {?} combo
     * @return {?}
     */
    NgxCheatsheetComponent.prototype.symbolize = /**
     * @param {?} combo
     * @return {?}
     */
    function (combo) {
        var /** @type {?} */ comboSplit = combo.split('+');
        for (var /** @type {?} */ i = 0; i < comboSplit.length; i++) {
            // try to resolve command / ctrl based on OS:
            if (comboSplit[i] === 'mod') {
                if (window.navigator && window.navigator.platform.indexOf('Mac') >= 0) {
                    comboSplit[i] = 'command';
                }
                else {
                    comboSplit[i] = 'ctrl';
                }
            }
            comboSplit[i] = this._map[comboSplit[i]] || comboSplit[i];
        }
        return comboSplit.join(' + ');
    };
    /**
     * @return {?}
     */
    NgxCheatsheetComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    NgxCheatsheetComponent.prototype.toggleCheatSheet = /**
     * @return {?}
     */
    function () {
        this.helpVisible = !this.helpVisible;
    };
    NgxCheatsheetComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-cheatsheet',
                    template: "<div class=\"ngx-cheatsheet fade\" [ngClass]=\"{'in': helpVisible}\" style=\"display:none\">\n  <div class=\"ngx-cheatsheet__hotkeys\">\n    <h4 class=\"ngx-cheatsheet__hotkeys__title\">{{ title }}</h4>\n    <table>\n      <tbody>\n      <tr *ngFor=\"let hotkey of hotkeys\">\n        <td class=\"ngx-cheatsheet__hotkeys__keys\">\n          <span class=\"ngx-cheatsheet__hotkeys__keys__key\">{{ formatHotkey(hotkey) }}</span>\n        </td>\n        <td class=\"ngx-cheatsheet__hotkeys__keys__text\">{{ hotkey.description }}</td>\n      </tr>\n      </tbody>\n    </table>\n    <div class=\"ngx-cheatsheet__hotkeys__close\" (click)=\"toggleCheatSheet()\">&#215;</div>\n  </div>\n</div>\n",
                    styles: [".ngx-cheatsheet{display:table!important;position:fixed;width:100%;height:100%;top:0;left:0;color:#333;font-size:1em;background-color:rgba(255,255,255,.9)}.ngx-cheatsheet.fade{z-index:-1024;visibility:hidden;opacity:0;transition:opacity .15s linear}.ngx-cheatsheet.fade.in{z-index:10002;visibility:visible;opacity:1}.ngx-cheatsheet__hotkeys{width:100%;height:100%;display:table-cell;vertical-align:middle}.ngx-cheatsheet__hotkeys__title{font-weight:700;text-align:center;font-size:1.2em}.ngx-cheatsheet__hotkeys table{margin:auto;color:#333}.ngx-cheatsheet__hotkeys__keys{padding:5px;text-align:right}.ngx-cheatsheet__hotkeys__keys__key{display:inline-block;color:#fff;background-color:#333;border:1px solid #333;border-radius:5px;text-align:center;margin-right:5px;box-shadow:inset 0 1px 0 #666,0 1px 0 #bbb;padding:5px 9px;font-size:1em}.ngx-cheatsheet__hotkeys__keys__text{padding-left:10px;font-size:1em}.ngx-cheatsheet__hotkeys__close{position:fixed;top:20px;right:20px;font-size:2em;font-weight:700;padding:5px 10px;border:1px solid #ddd;border-radius:5px;min-height:45px;min-width:45px;text-align:center}@media all and (max-width:500px){.ngx-cheatsheet__hotkeys{font-size:.8em}}@media all and (min-width:750px){.ngx-cheatsheet__hotkeys{font-size:1.2em}}"]
                },] },
    ];
    /** @nocollapse */
    NgxCheatsheetComponent.ctorParameters = function () { return [
        { type: NgxHotkeysService, },
    ]; };
    NgxCheatsheetComponent.propDecorators = {
        "title": [{ type: Input },],
    };
    return NgxCheatsheetComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgxHotkeysModule = /** @class */ (function () {
    function NgxHotkeysModule() {
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    NgxHotkeysModule.forRoot = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        return {
            ngModule: NgxHotkeysModule,
            providers: [
                NgxHotkeysService,
                { provide: HotkeyOptions, useValue: options }
            ]
        };
    };
    NgxHotkeysModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [NgxCheatsheetComponent, NgxHotkeysDirective],
                    exports: [NgxHotkeysDirective, NgxCheatsheetComponent],
                    providers: [NgxHotkeysService]
                },] },
    ];
    return NgxHotkeysModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { NgxHotkeysService, NgxHotkeysDirective, NgxCheatsheetComponent, NgxHotkeysModule, HotkeyOptions as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFsdGljY29kZS1uZ3gtaG90a2V5cy5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL3Rva2VuLnRzIiwibmc6Ly9AYmFsdGljY29kZS9uZ3gtaG90a2V5cy9saWIvbmd4LWhvdGtleXMuc2VydmljZS50cyIsIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL25neC1ob3RrZXlzLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL25neC1jaGVhdHNoZWV0L25neC1jaGVhdHNoZWV0LmNvbXBvbmVudC50cyIsIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL25neC1ob3RrZXlzLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdGlvblRva2VufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7SUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XHJcblxyXG5leHBvcnQgY29uc3QgSG90a2V5T3B0aW9ucyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxJSG90a2V5T3B0aW9ucz4oJ0hvdGtleU9wdGlvbnMnKTtcclxuIiwiaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgJ21vdXNldHJhcCc7XG5cbmltcG9ydCB7SUhvdGtleSwgSUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQge0hvdGtleU9wdGlvbnN9IGZyb20gJy4vdG9rZW4nO1xuaW1wb3J0IHtzaGFyZX0gZnJvbSAncnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMnO1xuXG5jb25zdCBfZGVmYXVsdE9wdGlvbnM6IElIb3RrZXlPcHRpb25zID0ge1xuICBkaXNhYmxlQ2hlYXRTaGVldDogZmFsc2UsXG4gIGNoZWF0U2hlZXRUaXRsZTogJ0tleWJvYXJkIFNob3J0Y3V0czonLFxuICBjaGVhdFNoZWV0SG90a2V5OiAnPycsXG4gIGNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvbjogJ1Nob3cgLyBoaWRlIHRoaXMgaGVscCBtZW51JyxcbiAgY2hlYXRTaGVldENsb3NlRXNjOiBmYWxzZSxcbiAgY2hlYXRTaGVldENsb3NlRXNjRGVzY3JpcHRpb246ICdIaWRlIHRoaXMgaGVscCBtZW51J1xufTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5neEhvdGtleXNTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zZXJ2aWNlT3B0aW9uczogSUhvdGtleU9wdGlvbnM7XG4gIHByaXZhdGUgX3JlZ2lzdGVyZWRIb3RrZXlzOiBTZXQ8SUhvdGtleT4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3BhdXNlZEhvdGtleXM6IFNldDxJSG90a2V5PiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfbW91c2V0cmFwSW5zdGFuY2U6IE1vdXNldHJhcEluc3RhbmNlO1xuICBwcml2YXRlIF9jaGVhdFNoZWV0VG9nZ2xlZDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcbiAgcHJpdmF0ZSBfcHJldmVudEluID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KEhvdGtleU9wdGlvbnMpIHByaXZhdGUgX29wdGlvbnM6IElIb3RrZXlPcHRpb25zKSB7XG4gICAgdGhpcy5fc2VydmljZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKF9kZWZhdWx0T3B0aW9ucywgdGhpcy5fb3B0aW9ucyk7XG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5zdG9wQ2FsbGJhY2sgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb21ibzogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJtb3VzZXRyYXBcIiB0aGVuIG5vIG5lZWQgdG8gc3RvcFxuICAgICAgaWYgKCgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiYgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gICAgfTtcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZSA9IG5ldyAoPGFueT5Nb3VzZXRyYXApKCk7XG4gICAgaWYgKCF0aGlzLl9zZXJ2aWNlT3B0aW9ucy5kaXNhYmxlQ2hlYXRTaGVldCkge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiB0aGlzLl9zZXJ2aWNlT3B0aW9ucy5jaGVhdFNoZWV0SG90a2V5LFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9jaGVhdFNoZWV0VG9nZ2xlZC5uZXh0KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzYykge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiAnZXNjJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQubmV4dChmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgYWxsb3dJbjogWydIT1RLRVlTLUNIRUFUU0hFRVQnXSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzY0Rlc2NyaXB0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBob3RrZXlzIGFzIGFycmF5LlxuICAgKiBAcmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBob3RrZXlzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhvdGtleXMoKTogSUhvdGtleVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9yZWdpc3RlcmVkSG90a2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHN0cmVhbSBpbmRpY2F0aW5nIHRoZSBjaGVhdHNoZWV0cyB2aXNpYmlsaXR5IHdhcyB0b2dnbGVkLlxuICAgKiBAcmV0dXJucyBzdHJlYW0gaW5kaWNhdGluZyB0aGUgY2hlYXRzaGVldHMgdmlzaWJpbGl0eSB3YXMgdG9nZ2xlZFxuICAgKi9cbiAgcHVibGljIGdldCBjaGVhdFNoZWV0VG9nZ2xlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQuYXNPYnNlcnZhYmxlKCkucGlwZShcbiAgICAgIHNoYXJlKClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCBvcHRpb25zKCk6IElIb3RrZXlPcHRpb25zIHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmljZU9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbmV3IGhvdGtleS9uZXcgaG90a2V5cyB3aXRoIGl0J3MvdGhlaXIgaGFuZGxlcihzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXlzIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHVucGF1c2luZyBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGhvdGtleXMgc2hvdWxkIGJlIHVucGF1c2VkXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXIoaG90a2V5OiBJSG90a2V5IHwgSUhvdGtleVtdLCB1bnBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGxldCBob3RrZXlzOiBJSG90a2V5W10gPSBbXS5jb25jYXQoaG90a2V5KTtcbiAgICBpZiAodW5wYXVzaW5nKSB7XG4gICAgICBob3RrZXlzID0gQXJyYXkuZnJvbSh0aGlzLl9wYXVzZWRIb3RrZXlzKTtcbiAgICB9XG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgaWYgKHVucGF1c2luZykge1xuICAgICAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmRlbGV0ZShoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRIb3RrZXlzLmFkZChoKTtcbiAgICAgIHRoaXMuYmluZFRvTW91c3RyYXAoaCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhL3RoZSByZWdpc3RlcmVkIGhvdGtleShzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXkgZmlsdGVyXG4gICAqIEBwYXJhbSBwYXVzaW5nIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgaG90a2V5cyBzaG91bGQgYmUgcGF1c2VkXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3Rlcihob3RrZXk6IElIb3RrZXkgfCBJSG90a2V5W10sIHBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuXG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuZGVsZXRlKGgpO1xuICAgICAgaWYgKHBhdXNpbmcpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkSG90a2V5cy5hZGQoaCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZS51bmJpbmQoaC5jb21ibywgaC5zcGVjaWZpY0V2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBob3RrZXlzIG1hdGNoaW5nIHRoZSBwYXNzZWQgY29tYm8ocykuXG4gICAqIEBwYXJhbSBjb21ibyBjb21ibyB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIGFsbCBtYXRjaGVkIGhvdGtleXNcbiAgICovXG4gIHB1YmxpYyBnZXQoY29tYm8/OiBzdHJpbmcgfCBzdHJpbmdbXSk6IElIb3RrZXlbXSB7XG4gICAgcmV0dXJuIHRoaXMuaG90a2V5cy5maWx0ZXIoaCA9PiBoLmNvbWJvID09PSBjb21ibyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHBhdXNlKGhvdGtleT86IElIb3RrZXkgfCBJSG90a2V5W10pOiB2b2lkIHtcbiAgICBpZiAoIWhvdGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF1c2UodGhpcy5ob3RrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgaG90a2V5czogSUhvdGtleVtdID0gW10uY29uY2F0KGhvdGtleSk7XG4gICAgdGhpcy51bnJlZ2lzdGVyKGhvdGtleXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHVucGF1c2UoaG90a2V5PzogSUhvdGtleSB8IElIb3RrZXlbXSk6IHZvaWQge1xuICAgIGlmICghaG90a2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhdXNlKHRoaXMuaG90a2V5cyk7XG4gICAgfVxuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuICAgIHRoaXMucmVnaXN0ZXIoaG90a2V5cywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGFsbCBob3RrZXlzLlxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLnJlc2V0KCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuY2xlYXIoKTtcbiAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmNsZWFyKCk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBiaW5kVG9Nb3VzdHJhcChob3RrZXk6IElIb3RrZXkpOiB2b2lkIHtcblxuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLmJpbmQoaG90a2V5LmNvbWJvLFxuICAgICAgKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBjb21ibzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyBpZiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgZGlyZWN0bHkgYGhvdGtleS5nZXQoJ3cnKS5jYWxsYmFjaygpYFxuICAgICAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGV2ZW50LCBzbyBqdXN0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50PihldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCk7IC8vIHNyY0VsZW1lbnQgaXMgSUUgb25seVxuICAgICAgICAgIGNvbnN0IG5vZGVOYW1lOiBzdHJpbmcgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbnB1dCBoYXMgYSBtb3VzZXRyYXAgY2xhc3MsIGFuZCBza2lwIGNoZWNraW5nIHByZXZlbnRJbiBpZiBzb1xuICAgICAgICAgIGlmICgoJyAnICsgdGFyZ2V0LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ByZXZlbnRJbi5pbmRleE9mKG5vZGVOYW1lKSA+IC0xICYmIGhvdGtleS5hbGxvd0luLm1hcChhbGxvdyA9PiBhbGxvdy50b1VwcGVyQ2FzZSgpKS5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgY2FsbGJhY2sgaWYgdGhlIGV2ZW50IHdhcyBmaXJlZCBmcm9tIGluc2lkZSBhbiBlbGVtZW50IGxpc3RlZCBpbiBwcmV2ZW50SW4gYnV0IG5vdCBpbiBhbGxvd0luXG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGUpIHtcbiAgICAgICAgICByZXR1cm4gaG90a2V5LmhhbmRsZXIuYXBwbHkodGhpcywgW2V2ZW50LCBjb21ib10pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaG90a2V5LnNwZWNpZmljRXZlbnQpO1xuICB9XG59XG4iLCJpbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCAnbW91c2V0cmFwJztcclxuXHJcbmltcG9ydCB7SG90S2V5TWFwLCBJSG90a2V5fSBmcm9tICcuL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQge05neEhvdGtleXNTZXJ2aWNlfSBmcm9tICcuL25neC1ob3RrZXlzLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbmd4SG90a2V5c10nLFxyXG4gIHByb3ZpZGVyczogW05neEhvdGtleXNTZXJ2aWNlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4SG90a2V5c0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgQElucHV0KClcclxuICBob3RrZXlzOiBIb3RLZXlNYXBbXTtcclxuXHJcbiAgcHJpdmF0ZSBfbW91c2V0cmFwSW5zdGFuY2U6IE1vdXNldHJhcEluc3RhbmNlO1xyXG4gIHByaXZhdGUgX2hvdGtleXNMaXN0OiBJSG90a2V5W10gPSBbXTtcclxuICBwcml2YXRlIF9vbGRIb3RrZXlzOiBJSG90a2V5W10gPSBbXTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaG90a2V5c1NlcnZpY2U6IE5neEhvdGtleXNTZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XHJcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZSA9IG5ldyBNb3VzZXRyYXAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTsgLy8gQmluZCBob3RrZXlzIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQgKGFuZCBhbnkgY2hpbGRyZW4pXHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIGZvciAoY29uc3QgaG90a2V5IG9mIHRoaXMuaG90a2V5cykge1xyXG4gICAgICBjb25zdCBjb21ibyA9IE9iamVjdC5rZXlzKGhvdGtleSlbMF07XHJcbiAgICAgIGNvbnN0IGhvdGtleU9iajogSUhvdGtleSA9IHtcclxuICAgICAgICBjb21ibzogY29tYm8sXHJcbiAgICAgICAgaGFuZGxlcjogaG90a2V5W2NvbWJvXVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZDogSUhvdGtleVtdID0gdGhpcy5faG90a2V5c1NlcnZpY2UuZ2V0KGNvbWJvKTtcclxuICAgICAgY29uc3Qgb2xkSG90a2V5OiBJSG90a2V5ID0gISFmaWx0ZXJlZCAmJiAhIWZpbHRlcmVkLmxlbmd0aCA/IGZpbHRlcmVkWzBdIDogbnVsbDtcclxuICAgICAgaWYgKG9sZEhvdGtleSAhPT0gbnVsbCkgeyAvLyBXZSBsZXQgdGhlIHVzZXIgb3ZlcndyaXRlIGNhbGxiYWNrcyB0ZW1wb3JhcmlseSBpZiB5b3Ugc3BlY2lmeSBpdCBpbiBIVE1MXHJcbiAgICAgICAgdGhpcy5fb2xkSG90a2V5cy5wdXNoKG9sZEhvdGtleSk7XHJcbiAgICAgICAgdGhpcy5faG90a2V5c1NlcnZpY2UudW5yZWdpc3RlcihvbGRIb3RrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2hvdGtleXNMaXN0LnB1c2goaG90a2V5T2JqKTtcclxuICAgICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UuYmluZChob3RrZXlPYmouY29tYm8sIGhvdGtleU9iai5oYW5kbGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgZm9yIChjb25zdCBob3RrZXkgb2YgdGhpcy5faG90a2V5c0xpc3QpIHtcclxuICAgICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UudW5iaW5kKGhvdGtleS5jb21ibyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9ob3RrZXlzU2VydmljZS5yZWdpc3Rlcih0aGlzLl9vbGRIb3RrZXlzKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7Tmd4SG90a2V5c1NlcnZpY2V9IGZyb20gJy4uL25neC1ob3RrZXlzLnNlcnZpY2UnO1xuaW1wb3J0IHtJSG90a2V5fSBmcm9tICcuLi9pbnRlcmZhY2VzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LWNoZWF0c2hlZXQnLFxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJuZ3gtY2hlYXRzaGVldCBmYWRlXCIgW25nQ2xhc3NdPVwieydpbic6IGhlbHBWaXNpYmxlfVwiIHN0eWxlPVwiZGlzcGxheTpub25lXCI+XG4gIDxkaXYgY2xhc3M9XCJuZ3gtY2hlYXRzaGVldF9faG90a2V5c1wiPlxuICAgIDxoNCBjbGFzcz1cIm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX190aXRsZVwiPnt7IHRpdGxlIH19PC9oND5cbiAgICA8dGFibGU+XG4gICAgICA8dGJvZHk+XG4gICAgICA8dHIgKm5nRm9yPVwibGV0IGhvdGtleSBvZiBob3RrZXlzXCI+XG4gICAgICAgIDx0ZCBjbGFzcz1cIm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX19rZXlzXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJuZ3gtY2hlYXRzaGVldF9faG90a2V5c19fa2V5c19fa2V5XCI+e3sgZm9ybWF0SG90a2V5KGhvdGtleSkgfX08L3NwYW4+XG4gICAgICAgIDwvdGQ+XG4gICAgICAgIDx0ZCBjbGFzcz1cIm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX19rZXlzX190ZXh0XCI+e3sgaG90a2V5LmRlc2NyaXB0aW9uIH19PC90ZD5cbiAgICAgIDwvdHI+XG4gICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG4gICAgPGRpdiBjbGFzcz1cIm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX19jbG9zZVwiIChjbGljayk9XCJ0b2dnbGVDaGVhdFNoZWV0KClcIj4mIzIxNTs8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gIHN0eWxlczogW2Aubmd4LWNoZWF0c2hlZXR7ZGlzcGxheTp0YWJsZSFpbXBvcnRhbnQ7cG9zaXRpb246Zml4ZWQ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt0b3A6MDtsZWZ0OjA7Y29sb3I6IzMzMztmb250LXNpemU6MWVtO2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuOSl9Lm5neC1jaGVhdHNoZWV0LmZhZGV7ei1pbmRleDotMTAyNDt2aXNpYmlsaXR5OmhpZGRlbjtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC4xNXMgbGluZWFyfS5uZ3gtY2hlYXRzaGVldC5mYWRlLmlue3otaW5kZXg6MTAwMDI7dmlzaWJpbGl0eTp2aXNpYmxlO29wYWNpdHk6MX0ubmd4LWNoZWF0c2hlZXRfX2hvdGtleXN7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246bWlkZGxlfS5uZ3gtY2hlYXRzaGVldF9faG90a2V5c19fdGl0bGV7Zm9udC13ZWlnaHQ6NzAwO3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZToxLjJlbX0ubmd4LWNoZWF0c2hlZXRfX2hvdGtleXMgdGFibGV7bWFyZ2luOmF1dG87Y29sb3I6IzMzM30ubmd4LWNoZWF0c2hlZXRfX2hvdGtleXNfX2tleXN7cGFkZGluZzo1cHg7dGV4dC1hbGlnbjpyaWdodH0ubmd4LWNoZWF0c2hlZXRfX2hvdGtleXNfX2tleXNfX2tleXtkaXNwbGF5OmlubGluZS1ibG9jaztjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzMzMztib3JkZXI6MXB4IHNvbGlkICMzMzM7Ym9yZGVyLXJhZGl1czo1cHg7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luLXJpZ2h0OjVweDtib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgIzY2NiwwIDFweCAwICNiYmI7cGFkZGluZzo1cHggOXB4O2ZvbnQtc2l6ZToxZW19Lm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX19rZXlzX190ZXh0e3BhZGRpbmctbGVmdDoxMHB4O2ZvbnQtc2l6ZToxZW19Lm5neC1jaGVhdHNoZWV0X19ob3RrZXlzX19jbG9zZXtwb3NpdGlvbjpmaXhlZDt0b3A6MjBweDtyaWdodDoyMHB4O2ZvbnQtc2l6ZToyZW07Zm9udC13ZWlnaHQ6NzAwO3BhZGRpbmc6NXB4IDEwcHg7Ym9yZGVyOjFweCBzb2xpZCAjZGRkO2JvcmRlci1yYWRpdXM6NXB4O21pbi1oZWlnaHQ6NDVweDttaW4td2lkdGg6NDVweDt0ZXh0LWFsaWduOmNlbnRlcn1AbWVkaWEgYWxsIGFuZCAobWF4LXdpZHRoOjUwMHB4KXsubmd4LWNoZWF0c2hlZXRfX2hvdGtleXN7Zm9udC1zaXplOi44ZW19fUBtZWRpYSBhbGwgYW5kIChtaW4td2lkdGg6NzUwcHgpey5uZ3gtY2hlYXRzaGVldF9faG90a2V5c3tmb250LXNpemU6MS4yZW19fWBdXG59KVxuZXhwb3J0IGNsYXNzIE5neENoZWF0c2hlZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KClcbiAgdGl0bGU6IHN0cmluZztcblxuICBoZWxwVmlzaWJsZSA9IGZhbHNlO1xuICBob3RrZXlzOiBJSG90a2V5W107XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSBfbWFwOiBhbnkgPSB7XG4gICAgY29tbWFuZDogJ1xcdTIzMTgnLCAgICAgICAvLyDDosKMwphcbiAgICBzaGlmdDogJ1xcdTIxRTcnLCAgICAgICAgIC8vIMOiwofCp1xuICAgIGxlZnQ6ICdcXHUyMTkwJywgICAgICAgICAgLy8gw6LChsKQXG4gICAgcmlnaHQ6ICdcXHUyMTkyJywgICAgICAgICAvLyDDosKGwpJcbiAgICB1cDogJ1xcdTIxOTEnLCAgICAgICAgICAgIC8vIMOiwobCkVxuICAgIGRvd246ICdcXHUyMTkzJywgICAgICAgICAgLy8gw6LChsKTXG4gICAgJ3JldHVybic6ICdcXHUyM0NFJywgICAgICAvLyDDosKPwo5cbiAgICBiYWNrc3BhY2U6ICdcXHUyMzJCJyAgICAgIC8vIMOiwozCq1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaG90a2V5c1NlcnZpY2U6IE5neEhvdGtleXNTZXJ2aWNlKSB7XG4gICAgdGhpcy50aXRsZSA9IHRoaXMuaG90a2V5c1NlcnZpY2Uub3B0aW9ucy5jaGVhdFNoZWV0VGl0bGU7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLmhvdGtleXNTZXJ2aWNlLmNoZWF0U2hlZXRUb2dnbGVkXG4gICAgICAuc3Vic2NyaWJlKChpc09wZW4pID0+IHtcbiAgICAgICAgaWYgKGlzT3BlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmhvdGtleXMgPSB0aGlzLmhvdGtleXNTZXJ2aWNlLmhvdGtleXNcbiAgICAgICAgICAgIC5maWx0ZXIoaG90a2V5ID0+IGhvdGtleS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuaGVscFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZUNoZWF0U2hlZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBmb3JtYXRIb3RrZXkoaG90a2V5OiBJSG90a2V5KTogc3RyaW5nW10ge1xuICAgIGlmICghaG90a2V5LmZvcm1hdCkge1xuICAgICAgY29uc3QgY29tYm86IHN0cmluZyA9IEFycmF5LmlzQXJyYXkoaG90a2V5LmNvbWJvKSA/IGhvdGtleS5jb21ib1swXSA6IGhvdGtleS5jb21ibztcbiAgICAgIGNvbnN0IHNlcXVlbmNlOiBzdHJpbmdbXSA9IGNvbWJvLnNwbGl0KC9bXFxzXS8pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXF1ZW5jZVtpXSA9IHRoaXMuc3ltYm9saXplKHNlcXVlbmNlW2ldKTtcbiAgICAgIH1cbiAgICAgIGhvdGtleS5mb3JtYXQgPSBzZXF1ZW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGhvdGtleS5mb3JtYXQ7XG4gIH1cblxuICBwcml2YXRlIHN5bWJvbGl6ZShjb21ibzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb21ib1NwbGl0OiBzdHJpbmdbXSA9IGNvbWJvLnNwbGl0KCcrJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21ib1NwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyB0cnkgdG8gcmVzb2x2ZSBjb21tYW5kIC8gY3RybCBiYXNlZCBvbiBPUzpcbiAgICAgIGlmIChjb21ib1NwbGl0W2ldID09PSAnbW9kJykge1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ01hYycpID49IDApIHtcbiAgICAgICAgICBjb21ib1NwbGl0W2ldID0gJ2NvbW1hbmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbWJvU3BsaXRbaV0gPSAnY3RybCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbWJvU3BsaXRbaV0gPSB0aGlzLl9tYXBbY29tYm9TcGxpdFtpXV0gfHwgY29tYm9TcGxpdFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJvU3BsaXQuam9pbignICsgJyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdG9nZ2xlQ2hlYXRTaGVldCgpOiB2b2lkIHtcbiAgICB0aGlzLmhlbHBWaXNpYmxlID0gIXRoaXMuaGVscFZpc2libGU7XG4gIH1cbn1cbiIsImltcG9ydCB7TW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7Tmd4Q2hlYXRzaGVldENvbXBvbmVudH0gZnJvbSAnLi9uZ3gtY2hlYXRzaGVldC9uZ3gtY2hlYXRzaGVldC5jb21wb25lbnQnO1xuaW1wb3J0IHtOZ3hIb3RrZXlzRGlyZWN0aXZlfSBmcm9tICcuL25neC1ob3RrZXlzLmRpcmVjdGl2ZSc7XG5pbXBvcnQge05neEhvdGtleXNTZXJ2aWNlfSBmcm9tICcuL25neC1ob3RrZXlzLnNlcnZpY2UnO1xuaW1wb3J0IHtIb3RrZXlPcHRpb25zfSBmcm9tICcuL3Rva2VuJztcbmltcG9ydCB7SUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtOZ3hDaGVhdHNoZWV0Q29tcG9uZW50LCBOZ3hIb3RrZXlzRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW05neEhvdGtleXNEaXJlY3RpdmUsIE5neENoZWF0c2hlZXRDb21wb25lbnRdLFxuICBwcm92aWRlcnM6IFtOZ3hIb3RrZXlzU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTmd4SG90a2V5c01vZHVsZSB7XG4gIHN0YXRpYyBmb3JSb290KG9wdGlvbnM/OiBJSG90a2V5T3B0aW9ucyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogTmd4SG90a2V5c01vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBOZ3hIb3RrZXlzU2VydmljZSxcbiAgICAgICAge3Byb3ZpZGU6IEhvdGtleU9wdGlvbnMsIHVzZVZhbHVlOiBvcHRpb25zfVxuICAgICAgXVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ0c2xpYl8xLl9fdmFsdWVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHFCQUlhLGFBQWEsR0FBRyxJQUFJLGNBQWMsQ0FBaUIsZUFBZSxDQUFDOzs7Ozs7QUNKaEYsQUFTQSxxQkFBTSxlQUFlLEdBQW1CO0lBQ3RDLGlCQUFpQixFQUFFLEtBQUs7SUFDeEIsZUFBZSxFQUFFLHFCQUFxQjtJQUN0QyxnQkFBZ0IsRUFBRSxHQUFHO0lBQ3JCLDJCQUEyQixFQUFFLDRCQUE0QjtJQUN6RCxrQkFBa0IsRUFBRSxLQUFLO0lBQ3pCLDZCQUE2QixFQUFFLHFCQUFxQjtDQUNyRCxDQUFDOztJQVlBLDJCQUEyQztRQUFBLGFBQVEsR0FBUixRQUFRO2tDQU5SLElBQUksR0FBRyxFQUFFOzhCQUNiLElBQUksR0FBRyxFQUFFO2tDQUVMLElBQUksT0FBTyxFQUFF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