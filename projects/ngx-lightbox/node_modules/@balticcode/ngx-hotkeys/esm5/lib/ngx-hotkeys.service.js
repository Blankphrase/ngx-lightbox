/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Inject, Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import 'mousetrap';
import { HotkeyOptions } from './token';
import { share } from 'rxjs/internal/operators';
var /** @type {?} */ _defaultOptions = {
    disableCheatSheet: false,
    cheatSheetTitle: 'Keyboard Shortcuts:',
    cheatSheetHotkey: '?',
    cheatSheetHotkeyDescription: 'Show / hide this help menu',
    cheatSheetCloseEsc: false,
    cheatSheetCloseEscDescription: 'Hide this help menu'
};
var NgxHotkeysService = /** @class */ (function () {
    function NgxHotkeysService(_options) {
        this._options = _options;
        this._registeredHotkeys = new Set();
        this._pausedHotkeys = new Set();
        this._cheatSheetToggled = new Subject();
        this._preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];
        this._serviceOptions = Object.assign(_defaultOptions, this._options);
        Mousetrap.prototype.stopCallback = function (event, element, combo, callback) {
            // if the element has the class "mousetrap" then no need to stop
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }
            return (element.contentEditable && element.contentEditable === 'true');
        };
        this._mousetrapInstance = new (/** @type {?} */ (Mousetrap))();
        if (!this._serviceOptions.disableCheatSheet) {
            this.register({
                combo: this._serviceOptions.cheatSheetHotkey,
                handler: function (event) {
                    this._cheatSheetToggled.next();
                }.bind(this),
                description: this._serviceOptions.cheatSheetHotkeyDescription
            });
        }
        if (this._serviceOptions.cheatSheetCloseEsc) {
            this.register({
                combo: 'esc',
                handler: function (event) {
                    this._cheatSheetToggled.next(false);
                }.bind(this),
                allowIn: ['HOTKEYS-CHEATSHEET'],
                description: this._serviceOptions.cheatSheetCloseEscDescription
            });
        }
    }
    Object.defineProperty(NgxHotkeysService.prototype, "hotkeys", {
        get: /**
         * Returns the registered hotkeys as array.
         * @return {?} all registered hotkeys
         */
        function () {
            return Array.from(this._registeredHotkeys);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxHotkeysService.prototype, "cheatSheetToggled", {
        get: /**
         * Returns an Observable stream indicating the cheatsheets visibility was toggled.
         * @return {?} stream indicating the cheatsheets visibility was toggled
         */
        function () {
            return this._cheatSheetToggled.asObservable().pipe(share());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxHotkeysService.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            return this._serviceOptions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    NgxHotkeysService.prototype.register = /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    function (hotkey, unpausing) {
        var _this = this;
        if (unpausing === void 0) { unpausing = false; }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        if (unpausing) {
            hotkeys = Array.from(this._pausedHotkeys);
        }
        hotkeys.forEach(function (h) {
            if (unpausing) {
                _this._pausedHotkeys.delete(h);
            }
            _this._registeredHotkeys.add(h);
            _this.bindToMoustrap(h);
        });
    };
    /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    NgxHotkeysService.prototype.unregister = /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    function (hotkey, pausing) {
        var _this = this;
        if (pausing === void 0) { pausing = false; }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        hotkeys.forEach(function (h) {
            _this._registeredHotkeys.delete(h);
            if (pausing) {
                _this._pausedHotkeys.add(h);
            }
            _this._mousetrapInstance.unbind(h.combo, h.specificEvent);
        });
    };
    /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    NgxHotkeysService.prototype.get = /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    function (combo) {
        return this.hotkeys.filter(function (h) { return h.combo === combo; });
    };
    /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    NgxHotkeysService.prototype.pause = /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    function (hotkey) {
        if (!hotkey) {
            return this.pause(this.hotkeys);
        }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        this.unregister(hotkeys, true);
    };
    /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    NgxHotkeysService.prototype.unpause = /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    function (hotkey) {
        if (!hotkey) {
            return this.unpause(this.hotkeys);
        }
        var /** @type {?} */ hotkeys = [].concat(hotkey);
        this.register(hotkeys, true);
    };
    /**
     * Resets all hotkeys.
     * @return {?}
     */
    NgxHotkeysService.prototype.reset = /**
     * Resets all hotkeys.
     * @return {?}
     */
    function () {
        this._mousetrapInstance.reset();
        this._registeredHotkeys.clear();
        this._pausedHotkeys.clear();
    };
    /**
     * @return {?}
     */
    NgxHotkeysService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.reset();
    };
    /**
     * @param {?} hotkey
     * @return {?}
     */
    NgxHotkeysService.prototype.bindToMoustrap = /**
     * @param {?} hotkey
     * @return {?}
     */
    function (hotkey) {
        var _this = this;
        this._mousetrapInstance.bind(hotkey.combo, function (event, combo) {
            var /** @type {?} */ shouldExecute = true;
            // if the callback is executed directly `hotkey.get('w').callback()`
            // there will be no event, so just execute the callback.
            if (event) {
                var /** @type {?} */ target = /** @type {?} */ ((event.target || event.srcElement)); // srcElement is IE only
                var /** @type {?} */ nodeName = target.nodeName.toUpperCase();
                // check if the input has a mousetrap class, and skip checking preventIn if so
                if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {
                    shouldExecute = true;
                }
                else if (_this._preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(function (allow) { return allow.toUpperCase(); }).indexOf(nodeName) === -1) {
                    // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn
                    shouldExecute = false;
                }
            }
            if (shouldExecute) {
                return hotkey.handler.apply(_this, [event, combo]);
            }
        }, hotkey.specificEvent);
    };
    NgxHotkeysService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NgxHotkeysService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [HotkeyOptions,] },] },
    ]; };
    return NgxHotkeysService;
}());
export { NgxHotkeysService };
function NgxHotkeysService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    NgxHotkeysService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    NgxHotkeysService.ctorParameters;
    /** @type {?} */
    NgxHotkeysService.prototype._serviceOptions;
    /** @type {?} */
    NgxHotkeysService.prototype._registeredHotkeys;
    /** @type {?} */
    NgxHotkeysService.prototype._pausedHotkeys;
    /** @type {?} */
    NgxHotkeysService.prototype._mousetrapInstance;
    /** @type {?} */
    NgxHotkeysService.prototype._cheatSheetToggled;
    /** @type {?} */
    NgxHotkeysService.prototype._preventIn;
    /** @type {?} */
    NgxHotkeysService.prototype._options;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWhvdGtleXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BiYWx0aWNjb2RlL25neC1ob3RrZXlzLyIsInNvdXJjZXMiOlsibGliL25neC1ob3RrZXlzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFZLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBYSxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFekMsT0FBTyxXQUFXLENBQUM7QUFHbkIsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUN0QyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFFOUMscUJBQU0sZUFBZSxHQUFtQjtJQUN0QyxpQkFBaUIsRUFBRSxLQUFLO0lBQ3hCLGVBQWUsRUFBRSxxQkFBcUI7SUFDdEMsZ0JBQWdCLEVBQUUsR0FBRztJQUNyQiwyQkFBMkIsRUFBRSw0QkFBNEI7SUFDekQsa0JBQWtCLEVBQUUsS0FBSztJQUN6Qiw2QkFBNkIsRUFBRSxxQkFBcUI7Q0FDckQsQ0FBQzs7SUFZQSwyQkFBMkM7UUFBQSxhQUFRLEdBQVIsUUFBUTtrQ0FOUixJQUFJLEdBQUcsRUFBRTs4QkFDYixJQUFJLEdBQUcsRUFBRTtrQ0FFTCxJQUFJLE9BQU8sRUFBRTswQkFDbkMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQztRQUdsRCxJQUFJLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNyRSxTQUFTLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxVQUFDLEtBQW9CLEVBQUUsT0FBb0IsRUFBRSxLQUFhLEVBQUUsUUFBa0I7O1lBRS9HLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLENBQUMs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QUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDbEIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQ25EO1NBQ0YsRUFDRCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7OztnQkEzSzNCLFVBQVU7Ozs7Z0RBVUksTUFBTSxTQUFDLGFBQWE7OzRCQTVCbkM7O1NBbUJhLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0LCBJbmplY3RhYmxlLCBPbkRlc3Ryb3l9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcblxuaW1wb3J0ICdtb3VzZXRyYXAnO1xuXG5pbXBvcnQge0lIb3RrZXksIElIb3RrZXlPcHRpb25zfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtIb3RrZXlPcHRpb25zfSBmcm9tICcuL3Rva2VuJztcbmltcG9ydCB7c2hhcmV9IGZyb20gJ3J4anMvaW50ZXJuYWwvb3BlcmF0b3JzJztcblxuY29uc3QgX2RlZmF1bHRPcHRpb25zOiBJSG90a2V5T3B0aW9ucyA9IHtcbiAgZGlzYWJsZUNoZWF0U2hlZXQ6IGZhbHNlLFxuICBjaGVhdFNoZWV0VGl0bGU6ICdLZXlib2FyZCBTaG9ydGN1dHM6JyxcbiAgY2hlYXRTaGVldEhvdGtleTogJz8nLFxuICBjaGVhdFNoZWV0SG90a2V5RGVzY3JpcHRpb246ICdTaG93IC8gaGlkZSB0aGlzIGhlbHAgbWVudScsXG4gIGNoZWF0U2hlZXRDbG9zZUVzYzogZmFsc2UsXG4gIGNoZWF0U2hlZXRDbG9zZUVzY0Rlc2NyaXB0aW9uOiAnSGlkZSB0aGlzIGhlbHAgbWVudSdcbn07XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ3hIb3RrZXlzU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgcHJpdmF0ZSBfc2VydmljZU9wdGlvbnM6IElIb3RrZXlPcHRpb25zO1xuICBwcml2YXRlIF9yZWdpc3RlcmVkSG90a2V5czogU2V0PElIb3RrZXk+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIF9wYXVzZWRIb3RrZXlzOiBTZXQ8SUhvdGtleT4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX21vdXNldHJhcEluc3RhbmNlOiBNb3VzZXRyYXBJbnN0YW5jZTtcbiAgcHJpdmF0ZSBfY2hlYXRTaGVldFRvZ2dsZWQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0KCk7XG4gIHByaXZhdGUgX3ByZXZlbnRJbiA9IFsnSU5QVVQnLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ107XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChIb3RrZXlPcHRpb25zKSBwcml2YXRlIF9vcHRpb25zOiBJSG90a2V5T3B0aW9ucykge1xuICAgIHRoaXMuX3NlcnZpY2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbihfZGVmYXVsdE9wdGlvbnMsIHRoaXMuX29wdGlvbnMpO1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUuc3RvcENhbGxiYWNrID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBlbGVtZW50OiBIVE1MRWxlbWVudCwgY29tYm86IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSA9PiB7XG4gICAgICAvLyBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIFwibW91c2V0cmFwXCIgdGhlbiBubyBuZWVkIHRvIHN0b3BcbiAgICAgIGlmICgoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyBtb3VzZXRyYXAgJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGVsZW1lbnQuY29udGVudEVkaXRhYmxlICYmIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICAgIH07XG4gICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UgPSBuZXcgKDxhbnk+TW91c2V0cmFwKSgpO1xuICAgIGlmICghdGhpcy5fc2VydmljZU9wdGlvbnMuZGlzYWJsZUNoZWF0U2hlZXQpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXIoe1xuICAgICAgICBjb21ibzogdGhpcy5fc2VydmljZU9wdGlvbnMuY2hlYXRTaGVldEhvdGtleSxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQubmV4dCgpO1xuICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLl9zZXJ2aWNlT3B0aW9ucy5jaGVhdFNoZWV0SG90a2V5RGVzY3JpcHRpb25cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2aWNlT3B0aW9ucy5jaGVhdFNoZWV0Q2xvc2VFc2MpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXIoe1xuICAgICAgICBjb21ibzogJ2VzYycsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgIHRoaXMuX2NoZWF0U2hlZXRUb2dnbGVkLm5leHQoZmFsc2UpO1xuICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgIGFsbG93SW46IFsnSE9US0VZUy1DSEVBVFNIRUVUJ10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLl9zZXJ2aWNlT3B0aW9ucy5jaGVhdFNoZWV0Q2xvc2VFc2NEZXNjcmlwdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgaG90a2V5cyBhcyBhcnJheS5cbiAgICogQHJldHVybnMgYWxsIHJlZ2lzdGVyZWQgaG90a2V5c1xuICAgKi9cbiAgcHVibGljIGdldCBob3RrZXlzKCk6IElIb3RrZXlbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSBzdHJlYW0gaW5kaWNhdGluZyB0aGUgY2hlYXRzaGVldHMgdmlzaWJpbGl0eSB3YXMgdG9nZ2xlZC5cbiAgICogQHJldHVybnMgc3RyZWFtIGluZGljYXRpbmcgdGhlIGNoZWF0c2hlZXRzIHZpc2liaWxpdHkgd2FzIHRvZ2dsZWRcbiAgICovXG4gIHB1YmxpYyBnZXQgY2hlYXRTaGVldFRvZ2dsZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWF0U2hlZXRUb2dnbGVkLmFzT2JzZXJ2YWJsZSgpLnBpcGUoXG4gICAgICBzaGFyZSgpXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgb3B0aW9ucygpOiBJSG90a2V5T3B0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMuX3NlcnZpY2VPcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIG5ldyBob3RrZXkvbmV3IGhvdGtleXMgd2l0aCBpdCdzL3RoZWlyIGhhbmRsZXIocykuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5cyB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB1bnBhdXNpbmcgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBob3RrZXlzIHNob3VsZCBiZSB1bnBhdXNlZFxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyKGhvdGtleTogSUhvdGtleSB8IElIb3RrZXlbXSwgdW5wYXVzaW5nID0gZmFsc2UpOiB2b2lkIHtcbiAgICBsZXQgaG90a2V5czogSUhvdGtleVtdID0gW10uY29uY2F0KGhvdGtleSk7XG4gICAgaWYgKHVucGF1c2luZykge1xuICAgICAgaG90a2V5cyA9IEFycmF5LmZyb20odGhpcy5fcGF1c2VkSG90a2V5cyk7XG4gICAgfVxuICAgIGhvdGtleXMuZm9yRWFjaChoID0+IHtcbiAgICAgIGlmICh1bnBhdXNpbmcpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkSG90a2V5cy5kZWxldGUoaCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWdpc3RlcmVkSG90a2V5cy5hZGQoaCk7XG4gICAgICB0aGlzLmJpbmRUb01vdXN0cmFwKGgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYS90aGUgcmVnaXN0ZXJlZCBob3RrZXkocykuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKiBAcGFyYW0gcGF1c2luZyBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGhvdGtleXMgc2hvdWxkIGJlIHBhdXNlZFxuICAgKi9cbiAgcHVibGljIHVucmVnaXN0ZXIoaG90a2V5OiBJSG90a2V5IHwgSUhvdGtleVtdLCBwYXVzaW5nID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCBob3RrZXlzOiBJSG90a2V5W10gPSBbXS5jb25jYXQoaG90a2V5KTtcblxuICAgIGhvdGtleXMuZm9yRWFjaChoID0+IHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRIb3RrZXlzLmRlbGV0ZShoKTtcbiAgICAgIGlmIChwYXVzaW5nKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZEhvdGtleXMuYWRkKGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UudW5iaW5kKGguY29tYm8sIGguc3BlY2lmaWNFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgaG90a2V5cyBtYXRjaGluZyB0aGUgcGFzc2VkIGNvbWJvKHMpLlxuICAgKiBAcGFyYW0gY29tYm8gY29tYm8gdG8gbWF0Y2ggYWdhaW5zdFxuICAgKiBAcmV0dXJucyBhbGwgbWF0Y2hlZCBob3RrZXlzXG4gICAqL1xuICBwdWJsaWMgZ2V0KGNvbWJvPzogc3RyaW5nIHwgc3RyaW5nW10pOiBJSG90a2V5W10ge1xuICAgIHJldHVybiB0aGlzLmhvdGtleXMuZmlsdGVyKGggPT4gaC5jb21ibyA9PT0gY29tYm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGxpc3RlbmluZyBmb3IgdGhlIHNwZWNpZmllZCBob3RrZXlzLlxuICAgKiBAcGFyYW0gaG90a2V5IGhvdGtleSBmaWx0ZXJcbiAgICovXG4gIHB1YmxpYyBwYXVzZShob3RrZXk/OiBJSG90a2V5IHwgSUhvdGtleVtdKTogdm9pZCB7XG4gICAgaWYgKCFob3RrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdXNlKHRoaXMuaG90a2V5cyk7XG4gICAgfVxuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuICAgIHRoaXMudW5yZWdpc3Rlcihob3RrZXlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIGxpc3RlbmluZyBmb3IgdGhlIHNwZWNpZmllZCBob3RrZXlzLlxuICAgKiBAcGFyYW0gaG90a2V5IGhvdGtleSBmaWx0ZXJcbiAgICovXG4gIHB1YmxpYyB1bnBhdXNlKGhvdGtleT86IElIb3RrZXkgfCBJSG90a2V5W10pOiB2b2lkIHtcbiAgICBpZiAoIWhvdGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYXVzZSh0aGlzLmhvdGtleXMpO1xuICAgIH1cbiAgICBjb25zdCBob3RrZXlzOiBJSG90a2V5W10gPSBbXS5jb25jYXQoaG90a2V5KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGhvdGtleXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBhbGwgaG90a2V5cy5cbiAgICovXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZS5yZXNldCgpO1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRIb3RrZXlzLmNsZWFyKCk7XG4gICAgdGhpcy5fcGF1c2VkSG90a2V5cy5jbGVhcigpO1xuICB9XG5cbiAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgYmluZFRvTW91c3RyYXAoaG90a2V5OiBJSG90a2V5KTogdm9pZCB7XG5cbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZS5iaW5kKGhvdGtleS5jb21ibyxcbiAgICAgIChldmVudDogS2V5Ym9hcmRFdmVudCwgY29tYm86IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgc2hvdWxkRXhlY3V0ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gaWYgdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIGRpcmVjdGx5IGBob3RrZXkuZ2V0KCd3JykuY2FsbGJhY2soKWBcbiAgICAgICAgLy8gdGhlcmUgd2lsbCBiZSBubyBldmVudCwgc28ganVzdCBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0OiBIVE1MRWxlbWVudCA9IDxIVE1MRWxlbWVudD4oZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQpOyAvLyBzcmNFbGVtZW50IGlzIElFIG9ubHlcbiAgICAgICAgICBjb25zdCBub2RlTmFtZTogc3RyaW5nID0gdGFyZ2V0Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgaW5wdXQgaGFzIGEgbW91c2V0cmFwIGNsYXNzLCBhbmQgc2tpcCBjaGVja2luZyBwcmV2ZW50SW4gaWYgc29cbiAgICAgICAgICBpZiAoKCcgJyArIHRhcmdldC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyBtb3VzZXRyYXAgJykgPiAtMSkge1xuICAgICAgICAgICAgc2hvdWxkRXhlY3V0ZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcmV2ZW50SW4uaW5kZXhPZihub2RlTmFtZSkgPiAtMSAmJiBob3RrZXkuYWxsb3dJbi5tYXAoYWxsb3cgPT4gYWxsb3cudG9VcHBlckNhc2UoKSkuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBleGVjdXRlIGNhbGxiYWNrIGlmIHRoZSBldmVudCB3YXMgZmlyZWQgZnJvbSBpbnNpZGUgYW4gZWxlbWVudCBsaXN0ZWQgaW4gcHJldmVudEluIGJ1dCBub3QgaW4gYWxsb3dJblxuICAgICAgICAgICAgc2hvdWxkRXhlY3V0ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRFeGVjdXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGhvdGtleS5oYW5kbGVyLmFwcGx5KHRoaXMsIFtldmVudCwgY29tYm9dKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhvdGtleS5zcGVjaWZpY0V2ZW50KTtcbiAgfVxufVxuIl19